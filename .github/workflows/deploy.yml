name: Build and Deploy

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Clean up disk space before build
        run: |
          echo "üßπ Cleaning up disk space..."
          # Remove unused Docker resources
          docker system prune -af --volumes || true

          # Check disk space
          echo "üíæ Disk space after cleanup:"
          df -h

      - name: Set up environment variables
        run: |
          echo "SERVICE_NAME=joker-backend" >> $GITHUB_ENV
          echo "SERVICE_PORT=6000" >> $GITHUB_ENV
          echo "DEPLOY_PATH=$HOME/services/joker-backend" >> $GITHUB_ENV

      - name: Create deployment directory
        run: |
          mkdir -p ${{ env.DEPLOY_PATH }}
          mkdir -p ${{ env.DEPLOY_PATH }}/logs

      - name: Copy project files
        run: |
          rsync -av --exclude='.git' --exclude='bin' --exclude='.claude*' \
            --exclude='node_modules' --exclude='.env' \
            ./ ${{ env.DEPLOY_PATH }}/

      - name: Check and use existing MySQL
        run: |
          # Check if port 3306 is already in use
          if sudo lsof -Pi :3306 -sTCP:LISTEN -t >/dev/null 2>&1; then
            echo "‚úÖ MySQL is already running on port 3306"

            # Find the container using port 3306
            MYSQL_CONTAINER=$(docker ps --filter "publish=3306" --format "{{.Names}}" | head -1)

            if [ -n "$MYSQL_CONTAINER" ]; then
              echo "üì¶ Using existing MySQL container: $MYSQL_CONTAINER"

              # Get the network of the existing MySQL container
              MYSQL_NETWORK=$(docker inspect $MYSQL_CONTAINER --format '{{range $key, $value := .NetworkSettings.Networks}}{{$key}}{{end}}')
              echo "üåê MySQL is using network: $MYSQL_NETWORK"

              echo "MYSQL_CONTAINER_NAME=$MYSQL_CONTAINER" >> $GITHUB_ENV
              echo "MYSQL_NETWORK=$MYSQL_NETWORK" >> $GITHUB_ENV
              echo "MYSQL_EXISTS=true" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è  Port 3306 is in use but not by a Docker container"
              echo "    Assuming external MySQL is available"
              echo "MYSQL_EXISTS=true" >> $GITHUB_ENV
            fi
          else
            echo "üÜï No MySQL found on port 3306, creating new container..."
            cd ${{ env.DEPLOY_PATH }}
            docker-compose -f docker-compose.prod.yml up -d mysql

            # Wait for MySQL to be ready
            for i in {1..10}; do
              if docker ps --filter "name=joker_mysql" --filter "status=running" | grep -q joker_mysql; then
                echo "MySQL container started"
                break
              fi
              echo "Waiting for MySQL container... ($i/10)"
              sleep 2
            done

            echo "MYSQL_CONTAINER_NAME=joker_mysql" >> $GITHUB_ENV
            echo "MYSQL_NETWORK=joker_network" >> $GITHUB_ENV
            echo "MYSQL_EXISTS=false" >> $GITHUB_ENV
          fi

      - name: Create production .env file
        run: |
          cat > ${{ env.DEPLOY_PATH }}/.env << EOF
          # Service Configuration
          SERVICE_NAME=${{ env.SERVICE_NAME }}
          PORT=${{ env.SERVICE_PORT }}

          # Database Configuration (Í≥µÏú† MySQL on port 3306)
          DB_HOST=${{ env.MYSQL_CONTAINER_NAME }}
          DB_PORT=3306
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}

          # Application Configuration
          LOG_LEVEL=info
          ENV=production
          EOF

      - name: Stop existing API container
        run: |
          # Stop only the API container, not MySQL
          docker stop ${{ env.SERVICE_NAME }}_api 2>/dev/null || true
          docker rm ${{ env.SERVICE_NAME }}_api 2>/dev/null || true

      - name: Build and start API container
        run: |
          cd ${{ env.DEPLOY_PATH }}

          # Build the API image first
          docker-compose -f docker-compose.prod.yml build api

          # Stop and remove old API container if exists
          docker stop ${{ env.SERVICE_NAME }}_api 2>/dev/null || true
          docker rm ${{ env.SERVICE_NAME }}_api 2>/dev/null || true

          # Get the image name that was just built
          IMAGE_NAME=$(docker-compose -f docker-compose.prod.yml images -q api | head -1)
          if [ -z "$IMAGE_NAME" ]; then
            IMAGE_NAME="joker-backend-api"
          fi
          echo "üì¶ Using image: $IMAGE_NAME"

          # Start API container and connect to MySQL network
          if [ "${{ env.MYSQL_EXISTS }}" == "true" ]; then
            echo "üîó Connecting API to MySQL network: ${{ env.MYSQL_NETWORK }}"
            docker run -d \
              --name ${{ env.SERVICE_NAME }}_api \
              --network ${{ env.MYSQL_NETWORK }} \
              --env-file .env \
              -p ${{ env.SERVICE_PORT }}:${{ env.SERVICE_PORT }} \
              --restart unless-stopped \
              $IMAGE_NAME
          else
            # Use docker-compose if we created our own MySQL
            docker-compose -f docker-compose.prod.yml up -d --no-deps api
          fi

      - name: Wait for services to be healthy
        run: |
          cd ${{ env.DEPLOY_PATH }}
          echo "Waiting for services to be ready..."
          sleep 10

          # Check MySQL health directly using docker exec
          for i in {1..30}; do
            if docker exec ${{ env.MYSQL_CONTAINER_NAME }} mysqladmin ping -h localhost --silent; then
              echo "‚úÖ MySQL is healthy"
              break
            fi
            echo "Waiting for MySQL... ($i/30)"
            sleep 2
          done

          # Check API health
          for i in {1..30}; do
            if curl -f http://localhost:${{ env.SERVICE_PORT }}/health > /dev/null 2>&1; then
              echo "‚úÖ API is healthy"
              break
            fi
            echo "Waiting for API... ($i/30)"
            sleep 2
          done

      - name: Verify deployment
        run: |
          # Check if containers are running
          cd ${{ env.DEPLOY_PATH }}
          docker-compose -f docker-compose.prod.yml ps

          # Test health endpoint
          echo "Testing health endpoint..."
          RESPONSE=$(curl -f http://localhost:${{ env.SERVICE_PORT }}/health)
          echo "Response: $RESPONSE"

          echo "‚úÖ Deployment successful!"
          echo "üìä Service: ${{ env.SERVICE_NAME }}"
          echo "üåê Port: ${{ env.SERVICE_PORT }}"
          echo "üîó Health: http://localhost:${{ env.SERVICE_PORT }}/health"

      - name: Cleanup old images and containers
        run: |
          echo "üßπ Cleaning up old resources..."
          docker image prune -af
          docker container prune -f

          echo "üíæ Final disk space:"
          df -h

      - name: Send deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment successful for ${{ env.SERVICE_NAME }} on port ${{ env.SERVICE_PORT }}"
          else
            echo "‚ùå Deployment failed for ${{ env.SERVICE_NAME }}"
          fi
